<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Guild Housing Map</title>
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="grid-overlay.css" />
  </head>
  <body>
    <div class="map-container">
      <div class="map-background" id="mapBackground">
        <!-- House plots will be dynamically positioned here -->
      </div>
    </div>

    <div class="legend-wrapper">
      <div class="legend-panel legend">
        <h3>Legend</h3>
        <div class="legend-item">
          <div class="legend-color available"></div>
          <span>Available</span>
        </div>
        <div class="legend-item">
          <div class="legend-color occupied"></div>
          <span>Occupied</span>
        </div>
        <div class="legend-shortcut">
          Press <strong>G</strong> to toggle grid
        </div>
      </div>

      <div class="legend-panel legend-roster" aria-live="polite">
        <h3>Plot Roster</h3>
        <div class="legend-roster-columns">
          <div
            class="legend-roster-column"
            id="legendRosterCol0"
            aria-label="Plots 0 through 19"
          ></div>
          <div
            class="legend-roster-column"
            id="legendRosterCol1"
            aria-label="Plots 20 through 39"
          ></div>
          <div
            class="legend-roster-column"
            id="legendRosterCol2"
            aria-label="Plots 40 through 55"
          ></div>
        </div>
      </div>
    </div>

    <script>
      // Housing data from CSV
      const housingData = {
        0: "Myetric",
        2: "Seyedo",
        4: "Ahmelya",
        6: "Zuk Gab",
        7: "Eeko",
        8: "Tham",
        9: "Stryfus",
        10: "Ceepo",
        11: "Suggma",
        12: "Acktbar",
        15: "Ramzi",
        17: "Black",
        18: "Tuber",
        20: "Leonna",
        21: "Sanman",
        22: "Pheonix",
        23: "Celthinor",
        24: "Zolbi",
        25: "TJ",
        27: "Xertas",
        28: "Haaruuk",
        31: "Sajak",
        32: "Seabohr",
        33: "Jacob",
        36: "Sabriya",
        38: "Zach",
        39: "Jarridan",
        40: "Handjabber",
        41: "Dari",
        42: "Naberus",
        44: "Honly",
        46: "Vorall",
        47: "Makima",
        48: "Azzurro",
        51: "Dolrok",
      };

      // House plot positions loaded from external JSON file
      let plotPositions = [];
      let mapImageData = {};

      async function loadPlotPositions() {
        try {
          const response = await fetch("plot-positions.json", {
            cache: "no-store",
          });
          const data = await response.json();
          plotPositions = data.plotPositions;
          mapImageData = data.referenceImage;
          console.log("Plot positions loaded successfully:", data);
        } catch (error) {
          console.error("Error loading plot positions:", error);
          plotPositions = [];
        }
      }

      function createHousePlots() {
        const mapBackground = document.getElementById("mapBackground");
        // Clear existing house plots only (don't remove flight markers!)
        const existingPlots = mapBackground.querySelectorAll(".house-plot");
        existingPlots.forEach((plot) => plot.remove());

        plotPositions.forEach((position) => {
          const plot = document.createElement("div");
          plot.className = "house-plot";
          plot.textContent = position.plotNumber;
          plot.dataset.plotNumber = position.plotNumber;

          // unique image per plot; tries jpg → jpeg → png
          const base = `/housing/plot_examples/plot_${position.plotNumber}`;
          plot.dataset.imgBase = base;

          const label = housingData[position.plotNumber]
            ? `Plot ${position.plotNumber}: ${housingData[position.plotNumber]}`
            : `Plot ${position.plotNumber}: Available`;
          plot.dataset.caption = label;

          // tooltip (kept as in your original)
          const tooltip = document.createElement("div");
          tooltip.className = "plot-info";
          tooltip.textContent = label;
          plot.appendChild(tooltip);

          // position
          plot.style.left = position.x + "px";
          plot.style.top = position.y + "px";

          if (housingData[position.plotNumber]) {
            plot.classList.add("occupied");
          }

          mapBackground.appendChild(plot);
        });
      }

      function buildLegendRoster() {
        const columnConfigs = [
          {
            element: document.getElementById("legendRosterCol0"),
            min: 0,
            max: 19,
          },
          {
            element: document.getElementById("legendRosterCol1"),
            min: 20,
            max: 39,
          },
          {
            element: document.getElementById("legendRosterCol2"),
            min: 40,
            max: 55,
          },
        ];

        if (columnConfigs.some((config) => !config.element)) {
          return;
        }

        columnConfigs.forEach((config) => {
          config.element.innerHTML = "";
        });

        const roster = plotPositions
          .slice()
          .sort((a, b) => a.plotNumber - b.plotNumber)
          .map((pos) => ({
            plotNumber: pos.plotNumber,
            occupant: housingData[pos.plotNumber] || "Available",
            status: housingData[pos.plotNumber] ? "occupied" : "available",
          }));

        if (!roster.length) {
          const empty = document.createElement("p");
          empty.textContent = "No plots loaded.";
          columnConfigs[0].element.appendChild(empty);
          return;
        }

        roster.forEach((entry) => {
          const targetConfig =
            columnConfigs.find(
              (config) =>
                entry.plotNumber >= config.min &&
                entry.plotNumber <= config.max,
            ) || columnConfigs[columnConfigs.length - 1];
          const targetColumn = targetConfig.element;
          const item = document.createElement("button");
          item.type = "button";
          item.className = `legend-roster-item ${entry.status}`;
          item.dataset.plotNumber = entry.plotNumber;

          const label = document.createElement("span");
          label.className = "legend-roster-label";
          label.textContent = `${entry.plotNumber} – ${entry.occupant}`;
          item.appendChild(label);

          item.addEventListener("mouseenter", () =>
            highlightPlot(entry.plotNumber),
          );
          item.addEventListener("mouseleave", clearPlotHighlight);
          item.addEventListener("focus", () => highlightPlot(entry.plotNumber));
          item.addEventListener("blur", clearPlotHighlight);

          targetColumn.appendChild(item);
        });

        requestAnimationFrame(updateLegendRosterLabelFades);
      }

      function updateLegendRosterLabelFades() {
        const labels = document.querySelectorAll(".legend-roster-label");
        labels.forEach((label) => {
          label.classList.remove("legend-roster-label--fade");
          if (label.scrollWidth > label.clientWidth) {
            label.classList.add("legend-roster-label--fade");
          }
        });
      }

      function highlightPlot(plotNumber) {
        clearPlotHighlight();
        const plot = document.querySelector(
          `.house-plot[data-plot-number="${plotNumber}"]`,
        );
        if (plot) {
          plot.classList.add("is-highlighted", "is-legend-hover");
        }
      }

      function clearPlotHighlight() {
        document
          .querySelectorAll(
            ".house-plot.is-highlighted, .house-plot.is-legend-hover",
          )
          .forEach((plot) =>
            plot.classList.remove("is-highlighted", "is-legend-hover"),
          );
      }

      function updatePlotPositions() {
        const mapBackground = document.getElementById("mapBackground");
        const plots = document.querySelectorAll(".house-plot");
        if (plots.length === 0) return;

        const mapImage = new Image();
        mapImage.onload = function () {
          const mapRect = mapBackground.getBoundingClientRect();
          const containerWidth = mapRect.width;
          const containerHeight = mapRect.height;

          const imageAspectRatio = mapImage.width / mapImage.height;
          const containerAspectRatio = containerWidth / containerHeight;

          let imageWidth, imageHeight, offsetX, offsetY;

          if (imageAspectRatio > containerAspectRatio) {
            imageWidth = containerWidth;
            imageHeight = containerWidth / imageAspectRatio;
            offsetX = 0;
            offsetY = (containerHeight - imageHeight) / 2;
          } else {
            imageHeight = containerHeight;
            imageWidth = containerHeight * imageAspectRatio;
            offsetX = (containerWidth - imageWidth) / 2;
            offsetY = 0;
          }

          const scaleX = imageWidth / mapImage.width;
          const scaleY = imageHeight / mapImage.height;

          plots.forEach((plot, index) => {
            const originalPos = plotPositions[index];
            if (originalPos) {
              const scaledX = offsetX + originalPos.x * scaleX;
              const scaledY = offsetY + originalPos.y * scaleY;
              plot.style.left = scaledX + "px";
              plot.style.top = scaledY + "px";
            }
          });
        };
        mapImage.src = "map.jpg";
      }

      // --- Utility to resolve first working image extension ---
      async function resolveImageSrc(baseNoExt) {
        const exts = [".jpg", ".jpeg", ".png"];
        for (const ext of exts) {
          const url = `${baseNoExt}${ext}`;
          try {
            const res = await fetch(url, { method: "HEAD", cache: "no-store" });
            if (res.ok) return url;
          } catch (_) {}
        }
        return null;
      }

      // Initialize everything after DOM is fully ready
      document.addEventListener("DOMContentLoaded", async function () {
        // Popover elements (moved here so they exist before we bind)
        const popover = document.getElementById("plotPopover");
        const popImg = document.getElementById("plotPopoverImg");
        const popCap = document.getElementById("plotPopoverCaption");
        const popClose = document.querySelector(".plot-popover-close");

        function closePlotPopover() {
          popover.setAttribute("aria-hidden", "true");
          popImg.removeAttribute("src");
          popImg.removeAttribute("alt");
        }

        async function openPlotPopover(baseSrc, caption) {
          popCap.textContent = caption || "";
          const resolved = await resolveImageSrc(baseSrc);
          if (!resolved) {
            popCap.textContent =
              (caption ? caption + " — " : "") + "(no preview available)";
            popImg.removeAttribute("src");
          } else {
            popImg.src = resolved;
            popImg.alt = caption || "Plot preview";
          }
          popover.setAttribute("aria-hidden", "false");
        }

        // Load plot positions and create plots
        await loadPlotPositions();
        createHousePlots();
        buildLegendRoster();

        // Bind click handlers now that plots exist
        document
          .getElementById("mapBackground")
          .addEventListener("click", async (e) => {
            const plot = e.target.closest(".house-plot");
            if (!plot) return;
            const base = plot.dataset.imgBase; // e.g., /housing/plot_examples/plot_12
            const cap = plot.dataset.caption || "";
            await openPlotPopover(base, cap);
          });

        // Close handlers
        popClose?.addEventListener("click", closePlotPopover);
        popover?.addEventListener("click", (e) => {
          if (e.target === popover) closePlotPopover();
        });
        window.addEventListener("keydown", (e) => {
          if (e.key === "Escape") closePlotPopover();
        });

        // Resize handling
        let plotResizeTimeout;
        window.addEventListener("resize", function () {
          clearTimeout(plotResizeTimeout);
          plotResizeTimeout = setTimeout(() => {
            updatePlotPositions();
            requestAnimationFrame(updateLegendRosterLabelFades);
          }, 75);
        });

        // Initial position update
        setTimeout(updatePlotPositions, 100);
      });
    </script>

    <script src="grid-overlay.js"></script>

    <script>
      /**
       * Overlay icons on #mapBackground using coordinates from a JSON file.
       * JSON shape: { positions: [{x, y}, ...] }
       */
      (async function overlayIcons(opts) {
        const {
          jsonUrl = "flight-positions.json",
          iconSrc = "icon_taxi_alliance.png",
          markerClass = "icon-marker",
          markerSize = 28,
          mapSelector = "#mapBackground",
          mapImageSrc = "map.jpg",
        } = opts || {};

        const mapBackground = document.querySelector(mapSelector);
        if (!mapBackground) return;

        const styleId = "overlay-icons-style-" + markerClass;
        let st = document.getElementById(styleId);
        if (!st) {
          st = document.createElement("style");
          st.id = styleId;
          document.head.appendChild(st);
        }
        st.textContent = `
          .${markerClass} {
            position: absolute;
            width: ${markerSize}px;
            height: ${markerSize}px;
            pointer-events: none;
            transform: translate(-50%, -100%);
            z-index: 2;
            filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));
          }
        `;

        let positions = [];
        let markers = [];

        try {
          const res = await fetch(jsonUrl, { cache: "no-store" });
          const data = await res.json();
          positions = Array.isArray(data.positions) ? data.positions : [];
        } catch (e) {
          console.error("overlayIcons: failed to load", jsonUrl, e);
          return;
        }

        function buildMarkers() {
          markers.forEach((m) => m.remove());
          markers = [];

          positions.forEach((p) => {
            const div = document.createElement("div");
            div.className = markerClass;
            div.style.backgroundImage = `url(${iconSrc})`;
            div.style.backgroundSize = "contain";
            div.style.backgroundRepeat = "no-repeat";
            div.style.backgroundPosition = "center";
            mapBackground.appendChild(div);
            markers.push(div);
          });
        }

        function reposition() {
          const mapRect = mapBackground.getBoundingClientRect();
          const W = mapRect.width,
            H = mapRect.height;

          const img = new Image();
          img.onload = () => {
            const ARimg = img.width / img.height;
            const ARcnt = W / H;

            let w, h, offX, offY;
            if (ARimg > ARcnt) {
              w = W;
              h = W / ARimg;
              offX = 0;
              offY = (H - h) / 2;
            } else {
              h = H;
              w = H * ARimg;
              offX = (W - w) / 2;
              offY = 0;
            }

            const sx = w / img.width;
            const sy = h / img.height;

            markers.forEach((m, i) => {
              const p = positions[i];
              if (!p) return;
              m.style.left = offX + p.x * sx + "px";
              m.style.top = offY + p.y * sy + "px";
            });
          };
          img.src = mapImageSrc;
        }

        buildMarkers();
        reposition();

        let t;
        window.addEventListener("resize", () => {
          clearTimeout(t);
          t = setTimeout(reposition, 50);
        });
      })({
        jsonUrl: "flight-positions.json",
        iconSrc: "icon_taxi_alliance.png",
        markerClass: "flight-marker-simple",
        markerSize: 32,
        mapSelector: "#mapBackground",
        mapImageSrc: "map.jpg",
      });
    </script>

    <!-- Popover / lightbox (you said this is already in your HTML; leaving it here for completeness) -->
    <div id="plotPopover" class="plot-popover" aria-hidden="true">
      <button class="plot-popover-close" aria-label="Close">&times;</button>
      <img id="plotPopoverImg" alt="Plot preview" />
      <div class="plot-popover-caption" id="plotPopoverCaption"></div>
    </div>
  </body>
</html>
